import * as t from '../iots';
import { LoiDecoratorConvert } from '../decorators/convert';
import { LoiFactory } from '../utilties/factory';
import { LoiFactoryBase } from './Base';
declare type Predicate<A> = (a: A) => boolean;
declare type Clean<T extends t.Any> = t.Type<T['_A'], T['_O'], T['_I']>;
export declare type LoiFactoryTypeNumber<T extends t.Any> = T & LoiFactoryNumber<T> & LoiFactoryBase<T>;
export declare class LoiFactoryNumber<T extends t.Any> extends LoiFactory<T> {
    max(limit: number): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    min(limit: number): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    greater(limit: number): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    less(limit: number): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    negative(): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    positive(): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    integer(): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    finite(): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    parseFloat(): LoiFactoryTypeNumber<Clean<LoiDecoratorConvert<this, string>>>;
    refinement(callback: Predicate<this["_A"]>, name?: string): LoiFactoryTypeNumber<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
}
export declare const number: (() => LoiFactoryTypeNumber<Clean<t.NumberType>>) & t.NumberType;
export {};
