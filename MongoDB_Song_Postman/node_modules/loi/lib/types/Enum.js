"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enumeration = exports.LoiFactoryEnum = exports.loiEnumTarget = void 0;
const t = require("../iots");
const factory_1 = require("../utilties/factory");
const lodash_1 = require("../utilties/lodash");
const Base_1 = require("./Base");
/** @internal */
exports.loiEnumTarget = Symbol('loiEnumTarget');
class LoiFactoryEnum extends factory_1.LoiFactory {
    /** @internal */
    static decorate(t) {
        return Base_1.LoiFactoryBase.decorate(factory_1.decorate(this, t));
    }
}
exports.LoiFactoryEnum = LoiFactoryEnum;
// https://github.com/Microsoft/TypeScript/blob/64504908449d39e34272d979537052f0cf52302f/src/compiler/checker.ts#L15700
// https://github.com/Microsoft/TypeScript/blob/64504908449d39e34272d979537052f0cf52302f/src/compiler/checker.ts#L24493
function isValidTypeScriptMemberName(name) {
    return !(isNumericLiteralName(name) && !isInfinityOrNaNString(name));
}
function isInfinityOrNaNString(name) {
    return name === "Infinity" || name === "-Infinity" || name === "NaN";
}
function isNumericLiteralName(name) {
    return (+name).toString() === name;
}
function enumeration(e, name) {
    const keys = Object.keys(e).filter((i) => {
        if (!lodash_1.isString(e[i]))
            return true;
        return isValidTypeScriptMemberName(i);
    });
    const others = [];
    const strings = {};
    let hasString = false;
    keys.forEach((k) => {
        const value = e[k];
        if (lodash_1.isString(value)) {
            strings[value] = null;
            hasString = true;
        }
        else {
            others.push(value);
        }
    });
    if (!name)
        name = `enum{${[...others, Object.keys(strings)].join(", ")}}`;
    let type;
    if (hasString && others.length == 0) {
        type = t.keyof(strings, name);
    }
    else if (hasString && others.length > 0) {
        type = t.union([t.keyof(strings), ...others.map((i) => t.literal(i))]);
    }
    else if (others.length > 0) {
        type = t.union([...others.map((i) => t.literal(i))]);
    }
    else {
        type = t.never;
    }
    return factory_1.metadata(LoiFactoryEnum.decorate(type), {
        tag: name
    });
}
exports.enumeration = enumeration;
;
//# sourceMappingURL=Enum.js.map