"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.object = exports.LoiFactoryObjectInitial = exports.LoiFactoryObject = exports.LoiTypeObjectViolet = exports.LoiTypeObjectStrict = exports.LoiTypeObject = exports.getNameFromProps = void 0;
const t = require("../iots");
const factory_1 = require("../utilties/factory");
const lodash_1 = require("../utilties/lodash");
const Base_1 = require("./Base");
/** @internal */
function getNameFromProps(required = {}, optional = {}) {
    const result = `{ ${[
        ...Object.keys(required).map((k) => `${k}: ${required[k].name}`),
        ...Object.keys(optional).map((k) => `${k}?: ${optional[k].name}`),
    ].join(', ')} }`;
    return result === "{  }" ? "{}" : result;
}
exports.getNameFromProps = getNameFromProps;
class LoiTypeObject extends t.Type {
    constructor(props, optionalProps, name = getNameFromProps(props, optionalProps)) {
        super(name, (loose = t.intersection([t.interface(props), t.partial(optionalProps)])).is, loose.validate, loose.encode);
        this.props = props;
        this.optionalProps = optionalProps;
        this._tag = 'LoiTypeObject';
        // [ts] A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.
        // tslint:disable-next-line:no-var-keyword
        var loose;
    }
}
exports.LoiTypeObject = LoiTypeObject;
LoiTypeObject._tag = 'LoiTypeObject';
/**
 * Return a new type that validates successfully only
 * when the instance (object) contains no unknow properties.
 *
 * https://github.com/gunzip/digital-citizenship-functions/blob/cd5c57629cb188dbda4b03037fbb399115fd6d29/lib/utils/types.ts#L92
 * https://github.com/gcanti/io-ts/issues/106
 *
 */
class LoiTypeObjectStrict extends t.Type {
    constructor(props, optionalProps, name = getNameFromProps(props, optionalProps)) {
        super(name, (v) => loose.is(v) && Object.getOwnPropertyNames(v).every((k) => allProps.hasOwnProperty(k)), (s, c) => loose.validate(s, c).chain((o) => {
            const errors = Object.getOwnPropertyNames(o)
                .map((key) => !allProps.hasOwnProperty(key)
                ? t.getValidationError(o[key], t.appendContext(c, key, t.never))
                : undefined)
                .filter((e) => e !== undefined);
            return errors.length ? t.failures(errors) : t.success(o);
        }), (loose = t.intersection([t.interface(props), t.partial(optionalProps)])).encode);
        this.props = props;
        this.optionalProps = optionalProps;
        this._tag = 'LoiTypeObjectStrict';
        // [ts] A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.
        // tslint:disable-next-line:no-var-keyword
        var loose;
        // tslint:disable-next-line:prefer-const no-var-keyword
        var allProps = Object.assign({}, props, optionalProps);
    }
}
exports.LoiTypeObjectStrict = LoiTypeObjectStrict;
LoiTypeObjectStrict._tag = 'LoiTypeObjectStrict';
class LoiTypeObjectViolet extends t.Type {
    constructor(props, optionalProps, name = getNameFromProps(props, optionalProps)) {
        super(name, (v) => loose.is(v), (s, c) => loose.validate(s, c).chain((o) => {
            const keys = Object.getOwnPropertyNames(o);
            const newObject = {};
            const len = keys.length;
            for (let i = 0; i < len; i++) {
                const key = keys[i];
                if (allProps.hasOwnProperty(key)) {
                    newObject[key] = o[key];
                }
            }
            return t.success(newObject);
        }), (loose = t.intersection([t.interface(props), t.partial(optionalProps)])).encode);
        this.props = props;
        this.optionalProps = optionalProps;
        this._tag = 'LoiTypeObjectViolet';
        // [ts] A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.
        // tslint:disable-next-line:no-var-keyword
        var loose;
        // tslint:disable-next-line:prefer-const no-var-keyword
        var allProps = Object.assign({}, props, optionalProps);
    }
}
exports.LoiTypeObjectViolet = LoiTypeObjectViolet;
LoiTypeObjectViolet._tag = 'LoiTypeObjectViolet';
class LoiFactoryObject extends factory_1.LoiFactory {
    /** @internal */
    static decorate(t) {
        return Base_1.LoiFactoryBase.decorate(factory_1.decorate(this, t));
    }
    type(constructor) {
        const type = t.refinement(this, (i) => i && i.constructor === constructor);
        return factory_1.metadata(LoiFactoryObject.decorate(type), {
            parent: this,
            option: { name: `type ${constructor.name}`, type: constructor }
        });
    }
    instanceof(constructor) {
        const type = t.refinement(this, (i) => i instanceof constructor);
        return factory_1.metadata(LoiFactoryObject.decorate(type), {
            parent: this,
            option: { name: `instanceof ${constructor.name}`, instanceof: constructor }
        });
    }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    asBaseType() {
        return this;
    }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    finish() { return this.asBaseType(); }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    end() { return this.asBaseType(); }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    simple() { return this.asBaseType(); }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    clean() { return this.asBaseType(); }
}
exports.LoiFactoryObject = LoiFactoryObject;
class LoiFactoryObjectInitial extends factory_1.LoiFactory {
    /** @internal */
    static decorate(t) {
        return LoiFactoryObject.decorate(Base_1.LoiFactoryBase.decorate(factory_1.decorate(this, t)));
    }
    strict() {
        const type = new LoiTypeObjectStrict(this.props, this.optionalProps, this.name);
        return factory_1.metadata(LoiFactoryObject.decorate(type), {
            parent: this,
            option: { name: `strict`, strict: true }
        });
    }
    violet() {
        const type = new LoiTypeObjectViolet(this.props, this.optionalProps, this.name);
        return factory_1.metadata(LoiFactoryObject.decorate(type), {
            parent: this,
            option: { name: `violet`, violet: true }
        });
    }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    finish() {
        return this;
    }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    end() {
        return this;
    }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    simple() {
        return this;
    }
    /**
     * Return the base io-ts type without Loi decorators.
     */
    clean() {
        return this;
    }
}
exports.LoiFactoryObjectInitial = LoiFactoryObjectInitial;
function object(a, b, c) {
    let required, optional, name;
    if ((a === null || a === undefined) && (b === null || b === undefined) && (c === null || c === undefined)) {
        required = {};
        optional = {};
        name = getNameFromProps(required, optional);
    }
    else if ((b === null || b === undefined) && (c === null || c === undefined)) {
        if (lodash_1.isString(a)) {
            required = {};
            optional = {};
            name = a;
        }
        else {
            required = a;
            optional = {};
            name = getNameFromProps(required, optional);
        }
    }
    else if ((c === null || c === undefined)) {
        if (lodash_1.isString(b)) {
            required = a;
            optional = {};
            name = b;
        }
        else {
            required = a;
            optional = b;
            name = getNameFromProps(required, optional);
        }
    }
    else {
        required = a;
        optional = b;
        name = c;
    }
    const type = new LoiTypeObject(required, optional, name);
    const decorated = factory_1.metadata(LoiFactoryObjectInitial.decorate(type), {
        tag: name
    });
    decorated.props = required;
    decorated.optionalProps = optional;
    return decorated;
}
exports.object = object;
//# sourceMappingURL=Object.js.map