"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.string = exports.LoiFactoryString = exports.LoiTypeString = void 0;
const t = require("../iots");
const factory_1 = require("../utilties/factory");
const lodash_1 = require("../utilties/lodash");
const mimic_1 = require("../utilties/mimic");
const Base_1 = require("./Base");
class LoiTypeString extends t.Type {
    constructor() {
        super('string', (m) => lodash_1.isString(m), (m, c) => (this.is(m) ? t.success(m.toString()) : t.failure(m, c)), t.identity);
        this._tag = 'LoiTypeString';
    }
}
exports.LoiTypeString = LoiTypeString;
LoiTypeString._tag = 'LoiTypeString';
class LoiFactoryString extends factory_1.LoiFactory {
    /** @internal */
    static decorate(t) {
        return Base_1.LoiFactoryBase.decorate(factory_1.decorate(this, t));
    }
    /**
     * Specifies the exact string length required
     * @param limit the required string length
     */
    length(limit) {
        const type = t.refinement(this, (i) => i.length == limit);
        return factory_1.metadata(LoiFactoryString.decorate(type), {
            parent: this,
            option: { name: `exact ${limit} chars`, length: limit }
        });
    }
    /**
     * Specifies the maximum number of string characters
     * @param limit the maximum number of string characters allowed
     */
    max(limit) {
        const type = t.refinement(this, (i) => i.length <= limit);
        return factory_1.metadata(LoiFactoryString.decorate(type), {
            parent: this,
            option: { name: `<=${limit} chars`, max: limit }
        });
    }
    /**
     * Specifies the minimum number string characters
     * @param limit the minimum number of string characters required
     */
    min(limit) {
        const type = t.refinement(this, (i) => i.length >= limit);
        return factory_1.metadata(LoiFactoryString.decorate(type), {
            parent: this,
            option: { name: `>=${limit} chars`, min: limit }
        });
    }
    /**
     * Defines a regular expression rule
     * @param pattern a regular expression object the string value must match against.
     * @param name optional name for patterns (useful with multiple patterns)
     */
    regex(pattern, name = `regexp ${pattern.toString()}`) {
        const type = t.refinement(this, (i) => i.match(pattern) !== null);
        return factory_1.metadata(LoiFactoryString.decorate(type), {
            parent: this,
            option: { name: name, regexp: pattern }
        });
    }
    /**
     * Defines a regular expression rule
     * @param pattern a regular expression object the string value must match against.
     * @param name optional name for patterns (useful with multiple patterns)
     */
    regexp(pattern, name) {
        return this.regex(pattern, name);
    }
    /**
     * Defines a regular expression rule
     * @param pattern a regular expression object the string value must match against.
     * @param name optional name for patterns (useful with multiple patterns)
     */
    pattern(pattern, name) {
        return this.regex(pattern, name);
    }
}
exports.LoiFactoryString = LoiFactoryString;
// tslint:disable-next-line:variable-name
exports.string = mimic_1.mimic(function string() {
    const type = new LoiTypeString();
    return factory_1.metadata(LoiFactoryString.decorate(type), {
        tag: "string"
    });
}, new LoiTypeString());
//# sourceMappingURL=String.js.map