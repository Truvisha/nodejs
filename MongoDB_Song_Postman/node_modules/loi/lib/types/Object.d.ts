import * as t from '../iots';
import { LoiFactory } from '../utilties/factory';
import { LoiFactoryBase } from './Base';
export declare type TypeOfPartialProps<P extends t.AnyProps> = {
    [K in keyof P]?: t.TypeOf<P[K]> | undefined;
};
export declare type OutputOfPartialProps<P extends t.AnyProps> = {
    [K in keyof P]?: t.OutputOf<P[K]> | undefined;
};
export declare class LoiTypeObject<R extends t.Props, O extends t.Props> extends t.Type<t.TypeOfProps<R> & TypeOfPartialProps<O>, t.OutputOfProps<R> & OutputOfPartialProps<O>> {
    readonly props: R;
    readonly optionalProps: O;
    static readonly _tag: 'LoiTypeObject';
    readonly _tag: 'LoiTypeObject';
    constructor(props: R, optionalProps: O, name?: string);
}
/**
 * Return a new type that validates successfully only
 * when the instance (object) contains no unknow properties.
 *
 * https://github.com/gunzip/digital-citizenship-functions/blob/cd5c57629cb188dbda4b03037fbb399115fd6d29/lib/utils/types.ts#L92
 * https://github.com/gcanti/io-ts/issues/106
 *
 */
export declare class LoiTypeObjectStrict<R extends t.Props, O extends t.Props> extends t.Type<t.TypeOfProps<R> & TypeOfPartialProps<O>, t.OutputOfProps<R> & OutputOfPartialProps<O>> {
    readonly props: R;
    readonly optionalProps: O;
    static readonly _tag: 'LoiTypeObjectStrict';
    readonly _tag: 'LoiTypeObjectStrict';
    constructor(props: R, optionalProps: O, name?: string);
}
export declare class LoiTypeObjectViolet<R extends t.Props, O extends t.Props> extends t.Type<t.TypeOfProps<R> & TypeOfPartialProps<O>, t.OutputOfProps<R> & OutputOfPartialProps<O>> {
    readonly props: R;
    readonly optionalProps: O;
    static readonly _tag: 'LoiTypeObjectViolet';
    readonly _tag: 'LoiTypeObjectViolet';
    constructor(props: R, optionalProps: O, name?: string);
}
declare type Clean<T extends t.Any> = t.Type<T['_A'], T['_O'], T['_I']>;
export declare type LoiFactoryTypeObject<R extends t.Props, O extends t.Props, T extends t.Any> = T & LoiFactoryObject<R, O, T> & LoiFactoryBase<T>;
export declare type LoiFactoryTypeObjectInitial<R extends t.Props, O extends t.Props, T extends t.Any> = T & LoiFactoryObjectInitial<R, O, T> & LoiFactoryObject<R, O, T> & LoiFactoryBase<T>;
export declare class LoiFactoryObject<R extends t.Props, O extends t.Props, T extends t.Any> extends LoiFactory<T> {
    props: R;
    optionalProps: O;
    type<F>(constructor: {
        new (...args: any[]): F;
    }): LoiFactoryTypeObject<R, O, Clean<t.Type<this["_A"] & F, this["_O"] & F, this["_I"]>>>;
    instanceof<F>(constructor: {
        new (...args: any[]): F;
    }): LoiFactoryTypeObject<R, O, Clean<t.Type<this["_A"] & F, this["_O"] & F, this["_I"]>>>;
    /**
     * Return the base io-ts type without Loi decorators.
     */
    asBaseType(): t.Type<T['_A'], T['_O'], T['_I']> & {
        props: R;
        optionalProps: O;
    };
    /**
     * Return the base io-ts type without Loi decorators.
     */
    finish(): t.Type<T["_A"], T["_O"], T["_I"]> & {
        props: R;
        optionalProps: O;
    };
    /**
     * Return the base io-ts type without Loi decorators.
     */
    end(): t.Type<T["_A"], T["_O"], T["_I"]> & {
        props: R;
        optionalProps: O;
    };
    /**
     * Return the base io-ts type without Loi decorators.
     */
    simple(): t.Type<T["_A"], T["_O"], T["_I"]> & {
        props: R;
        optionalProps: O;
    };
    /**
     * Return the base io-ts type without Loi decorators.
     */
    clean(): t.Type<T["_A"], T["_O"], T["_I"]> & {
        props: R;
        optionalProps: O;
    };
}
export declare class LoiFactoryObjectInitial<R extends t.Props, O extends t.Props, T extends t.Any> extends LoiFactory<T> {
    props: R;
    optionalProps: O;
    strict(): LoiFactoryTypeObject<R, O, Clean<T>>;
    violet(): LoiFactoryTypeObject<R, O, Clean<T>>;
    /**
     * Return the base io-ts type without Loi decorators.
     */
    finish(): t.Type<T['_A'], T['_O'], T['_I']> & {
        props: R;
        optionalProps: O;
    };
    /**
     * Return the base io-ts type without Loi decorators.
     */
    end(): t.Type<T['_A'], T['_O'], T['_I']> & {
        props: R;
        optionalProps: O;
    };
    /**
     * Return the base io-ts type without Loi decorators.
     */
    simple(): t.Type<T['_A'], T['_O'], T['_I']> & {
        props: R;
        optionalProps: O;
    };
    /**
     * Return the base io-ts type without Loi decorators.
     */
    clean(): t.Type<T['_A'], T['_O'], T['_I']> & {
        props: R;
        optionalProps: O;
    };
}
export declare function object(name?: string): LoiFactoryTypeObjectInitial<{}, {}, t.Type<{}, {}, t.mixed>>;
export declare function object<R extends t.Props = {}>(required: R, name?: string): LoiFactoryTypeObjectInitial<{
    [K in keyof R]: t.Type<R[K]['_A'], R[K]['_O'], R[K]['_I']>;
}, {}, t.Type<{
    [K in keyof R]: t.TypeOf<R[K]>;
}, {
    [K in keyof R]: t.OutputOf<R[K]>;
}, t.mixed>>;
export declare function object<R extends t.Props = {}, O extends t.Props = {}>(required: R, optional: O, name?: string): LoiFactoryTypeObjectInitial<{
    [K in keyof R]: t.Type<R[K]['_A'], R[K]['_O'], R[K]['_I']>;
}, {
    [K in keyof O]: t.Type<O[K]['_A'], O[K]['_O'], O[K]['_I']>;
}, t.Type<{
    [K in keyof R]: t.TypeOf<R[K]>;
} & {
    [K in keyof O]?: t.TypeOf<O[K]>;
}, {
    [K in keyof R]: t.OutputOf<R[K]>;
} & {
    [K in keyof O]?: t.OutputOf<O[K]>;
}, t.mixed>>;
export {};
