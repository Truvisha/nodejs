import * as t from '../iots';
import { LoiDecoratorConvert } from '../decorators/convert';
import { LoiFactory } from '../utilties/factory';
import { LoiFactoryBase } from './Base';
declare type Clean<T extends t.Any> = t.Type<T['_A'], T['_O'], T['_I']>;
export declare type LoiFactoryTypeBoolean<T extends t.Any> = T & LoiFactoryBoolean<T> & LoiFactoryBase<T>;
export declare type LoiFactoryTypeBooleanInitial<T extends t.Any> = T & LoiFactoryBooleanInitial<T> & LoiFactoryBoolean<T> & LoiFactoryBase<T>;
export declare class LoiFactoryBoolean<T extends t.Any> extends LoiFactory<T> {
    parseString(): LoiFactoryTypeBoolean<Clean<LoiDecoratorConvert<this, this["_I"]>>>;
    parseNumber(): LoiFactoryTypeBoolean<Clean<LoiDecoratorConvert<this, this["_I"]>>>;
    parse(): LoiFactoryTypeBoolean<Clean<LoiDecoratorConvert<LoiFactoryTypeBoolean<Clean<LoiDecoratorConvert<this, this["_I"]>>>, this["_I"]>>>;
}
export declare class LoiFactoryBooleanInitial<T extends t.Any> extends LoiFactory<T> {
    trueOnly(violet: true): LoiFactoryTypeBoolean<t.Type<true | undefined, true | undefined, this["_I"]>>;
    trueOnly(violet?: false): LoiFactoryTypeBoolean<t.Type<true, true, this["_I"]>>;
    falseOnly(violet: true): LoiFactoryTypeBoolean<t.Type<false | undefined, false | undefined, this["_I"]>>;
    falseOnly(violet?: false): LoiFactoryTypeBoolean<t.Type<false, false, this["_I"]>>;
}
export declare const boolean: (() => LoiFactoryTypeBooleanInitial<Clean<t.BooleanType>>) & t.BooleanType;
export {};
