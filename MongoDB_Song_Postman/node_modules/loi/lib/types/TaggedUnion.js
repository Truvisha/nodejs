"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.taggedUnion = exports.getTagValue = exports.isTagged = void 0;
const iots_1 = require("../iots");
const tag_1 = require("../utilties/tag");
const Object_1 = require("./Object");
const isTagged = (tag) => {
    const f = (type) => {
        if (type instanceof iots_1.InterfaceType || type instanceof iots_1.StrictType) {
            return type.props.hasOwnProperty(tag);
        }
        else if (type instanceof iots_1.IntersectionType) {
            return type.types.some(f);
        }
        else if (type instanceof iots_1.UnionType) {
            return type.types.every(f);
        }
        else if (type instanceof iots_1.RefinementType || type instanceof iots_1.ExactType) {
            return f(type.type);
        }
        else if (tag_1.isDecoratorType(type)) {
            return f(type.type);
        }
        else if (type instanceof Object_1.LoiTypeObject || type instanceof Object_1.LoiTypeObjectStrict || type instanceof Object_1.LoiTypeObjectViolet) {
            return type.props.hasOwnProperty(tag);
        }
        else {
            return false;
        }
    };
    return f;
};
exports.isTagged = isTagged;
const findTagged = (tag, types) => {
    const len = types.length;
    const is = exports.isTagged(tag);
    let i = 0;
    for (; i < len - 1; i++) {
        const type = types[i];
        if (is(type)) {
            return type;
        }
    }
    return types[i];
};
const getTagValue = (tag) => {
    const f = (type) => {
        if (type instanceof iots_1.InterfaceType || type instanceof iots_1.StrictType) {
            return type.props[tag].value;
        }
        else if (type instanceof iots_1.IntersectionType) {
            return f(findTagged(tag, type.types));
        }
        else if (type instanceof iots_1.UnionType) {
            return f(type.types[0]);
        }
        else if (type instanceof iots_1.RefinementType || type instanceof iots_1.ExactType) {
            return f(type.type);
        }
        else if (tag_1.isDecoratorType(type)) {
            return f(type.type);
        }
        else if (type instanceof Object_1.LoiTypeObject || type instanceof Object_1.LoiTypeObjectStrict || type instanceof Object_1.LoiTypeObjectViolet) {
            return type.props[tag].value;
        }
        throw new Error("Cannot get tag value");
    };
    return f;
};
exports.getTagValue = getTagValue;
const taggedUnion = (tag, types, name = `(${types.map((type) => type.name).join(' | ')})`) => {
    const len = types.length;
    const values = new Array(len);
    const hash = {};
    let useHash = true;
    const get = exports.getTagValue(tag);
    for (let i = 0; i < len; i++) {
        const value = get(types[i]);
        useHash = useHash && iots_1.string.is(value);
        values[i] = value;
        hash[String(value)] = i;
    }
    const isTagValue = useHash
        ? (m) => iots_1.string.is(m) && hash.hasOwnProperty(m)
        : (m) => values.indexOf(m) !== -1;
    const getIndex = useHash
        ? (tag) => hash[tag]
        : (tag) => {
            let i = 0;
            for (; i < len - 1; i++) {
                if (values[i] === tag) {
                    break;
                }
            }
            return i;
        };
    const TagValue = new iots_1.Type(values.map((l) => JSON.stringify(l)).join(' | '), isTagValue, (m, c) => (isTagValue(m) ? iots_1.success(m) : iots_1.failure(m, c)), iots_1.identity);
    const TagOnlyType = iots_1.interface({
        [tag]: TagValue
    }, name);
    return new iots_1.UnionType(name, (v) => {
        if (!iots_1.Dictionary.is(v)) {
            return false;
        }
        const tagValue = v[tag];
        return TagValue.is(tagValue) && types[getIndex(tagValue)].is(v);
    }, (s, c) => {
        const dictionaryValidation = iots_1.Dictionary.validate(s, c);
        if (dictionaryValidation.isLeft()) {
            return dictionaryValidation;
        }
        else {
            const d = dictionaryValidation.value;
            const tagValueValidation = TagValue.validate(d[tag], iots_1.appendContext(iots_1.appendContext(c, "-1", TagOnlyType), tag, TagValue));
            if (tagValueValidation.isLeft()) {
                return tagValueValidation;
            }
            else {
                const i = getIndex(tagValueValidation.value);
                const type = types[i];
                return type.validate(d, iots_1.appendContext(c, String(i), type));
            }
        }
    }, types.every((type) => type.encode === iots_1.identity) ? iots_1.identity : (a) => types[getIndex(a[tag])].encode(a), types);
};
exports.taggedUnion = taggedUnion;
//# sourceMappingURL=TaggedUnion.js.map