import * as t from '../iots';
import { LoiFactory } from '../utilties/factory';
import { LoiFactoryBase } from './Base';
export declare class LoiTypeString extends t.Type<string> {
    static readonly _tag: 'LoiTypeString';
    readonly _tag: 'LoiTypeString';
    constructor();
}
declare type Clean<T extends t.Any> = t.Type<T['_A'], T['_O'], T['_I']>;
export declare type LoiFactoryTypeString<T extends t.Any> = T & LoiFactoryString<T> & LoiFactoryBase<T>;
export declare class LoiFactoryString<T extends t.Any> extends LoiFactory<T> {
    /**
     * Specifies the exact string length required
     * @param limit the required string length
     */
    length(limit: number): LoiFactoryTypeString<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    /**
     * Specifies the maximum number of string characters
     * @param limit the maximum number of string characters allowed
     */
    max(limit: number): LoiFactoryTypeString<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    /**
     * Specifies the minimum number string characters
     * @param limit the minimum number of string characters required
     */
    min(limit: number): LoiFactoryTypeString<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    /**
     * Defines a regular expression rule
     * @param pattern a regular expression object the string value must match against.
     * @param name optional name for patterns (useful with multiple patterns)
     */
    regex(pattern: RegExp, name?: string): LoiFactoryTypeString<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    /**
     * Defines a regular expression rule
     * @param pattern a regular expression object the string value must match against.
     * @param name optional name for patterns (useful with multiple patterns)
     */
    regexp(pattern: RegExp, name?: string): LoiFactoryTypeString<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
    /**
     * Defines a regular expression rule
     * @param pattern a regular expression object the string value must match against.
     * @param name optional name for patterns (useful with multiple patterns)
     */
    pattern(pattern: RegExp, name?: string): LoiFactoryTypeString<Clean<t.RefinementType<this, t.TypeOf<this>, t.OutputOf<this>, t.InputOf<this>>>>;
}
export declare const string: (() => LoiFactoryTypeString<Clean<LoiTypeString>>) & LoiTypeString;
export {};
