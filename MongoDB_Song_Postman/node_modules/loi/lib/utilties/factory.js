"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.metadata = exports.decorate = exports.LoiFactory = exports.loiOption = exports.loiTag = void 0;
const t = require("../iots");
/** @internal */
exports.loiTag = Symbol('loiTag');
/** @internal */
exports.loiOption = Symbol('loiOption');
class LoiFactory extends t.Type {
    constructor() {
        throw new Error('The Loi factory class cannot be constructored.');
        // [ts] Constructors for derived classes must contain a 'super' call.
        // [ts] Unreachable code detected.
        // @ts-ignore
        /* istanbul ignore next */ const pitfall = undefined; /* istanbul ignore next */
        super(pitfall, pitfall, pitfall, pitfall);
    }
}
exports.LoiFactory = LoiFactory;
const factoryMaps = new WeakMap();
function getFactoryMap(klass) {
    if (factoryMaps.has(klass)) {
        return factoryMaps.get(klass);
    }
    const map = new Map();
    factoryMaps.set(klass, map);
    return map;
}
function copyFactoryMethod(klass, destination) {
    Object.getOwnPropertyNames(klass.prototype).forEach((i) => {
        if (i === 'constructor')
            return;
        destination[i] = klass.prototype[i];
    });
}
function createPrototype(klass, base) {
    const prototype = Object.create(base);
    copyFactoryMethod(klass, prototype);
    return prototype;
}
/** @internal */
function decorate(factory, t) {
    if (!t)
        return t;
    const result = t;
    const base = Object.getPrototypeOf(result);
    if (!base) {
        copyFactoryMethod(factory, result);
    }
    else {
        const map = getFactoryMap(base);
        let prototype = map.get(factory);
        if (!prototype) {
            prototype = createPrototype(factory, base);
            map.set(factory, prototype);
        }
        Object.setPrototypeOf(result, prototype);
    }
    return result;
}
exports.decorate = decorate;
/** @internal */
function metadata(t, params) {
    let previousOptions = (params && params.parent && params.parent[exports.loiOption] || []);
    if (params && params.optionFilter) {
        previousOptions = Array.prototype.filter.call(previousOptions, params.optionFilter);
    }
    const tag = (params && params.tag) || (t && t[exports.loiTag]) || (params && params.parent && params.parent[exports.loiTag]) || (t && t.name) || "unknown";
    const options = [...previousOptions, ...(params && params.option ? [params && params.option] : [])];
    t.name = `${tag}${options.length ? `(${options.map((i) => i.name || JSON.stringify(i)).join(", ")})` : ""}`;
    t[exports.loiTag] = tag;
    t[exports.loiOption] = options;
    return t;
}
exports.metadata = metadata;
//# sourceMappingURL=factory.js.map