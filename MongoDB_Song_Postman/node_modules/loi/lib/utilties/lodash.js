"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPlainObject = exports.isDate = exports.isString = exports.isNumber = exports.isObjectLike = exports.isArray = exports.objectForEach = exports.objectMapValues = void 0;
/* istanbul ignore next */
/** @internal */
function objectMapValues(collection, callback) {
    const result = {};
    for (const key in collection) {
        if (collection.hasOwnProperty(key)) {
            const value = collection[key];
            result[key] = callback(value, key, collection);
        }
    }
    return result;
}
exports.objectMapValues = objectMapValues;
;
/* istanbul ignore next */
/** @internal */
function objectForEach(collection, iteratee) {
    for (const key in collection) {
        if (collection.hasOwnProperty(key)) {
            const value = collection[key];
            iteratee(value, key, collection);
        }
    }
    return collection;
}
exports.objectForEach = objectForEach;
// The following code copied from lodash@4.17.10
const funcProto = Function.prototype;
const objectProto = Object.prototype;
const getPrototypeOf = Object.getPrototypeOf.bind(Object);
const hasOwnProperty = objectProto.hasOwnProperty;
const funcToString = funcProto.toString;
const objectCtorString = funcToString.call(Object);
const nativeObjectToString = objectProto.toString;
/* istanbul ignore next */
const symToStringTag = Symbol ? Symbol.toStringTag : undefined;
const nullTag = '[object Null]';
const undefinedTag = '[object Undefined]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const dateTag = '[object Date]';
const objectTag = '[object Object]';
/* istanbul ignore next */
function getRawTag(value) {
    if (!symToStringTag)
        return;
    let unmasked = false;
    const isOwn = hasOwnProperty.call(value, symToStringTag);
    const tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) { }
    const result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        }
        else {
            delete value[symToStringTag];
        }
    }
    return result;
}
/* istanbul ignore next */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : nativeObjectToString.call(value);
}
/** @internal */
exports.isArray = Array.isArray;
/* istanbul ignore next */
/** @internal */
function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
exports.isObjectLike = isObjectLike;
/* istanbul ignore next */
/** @internal */
function isNumber(value) {
    return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
}
exports.isNumber = isNumber;
/* istanbul ignore next */
/** @internal */
function isString(value) {
    return typeof value == 'string' ||
        (!exports.isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}
exports.isString = isString;
/* istanbul ignore next */
/** @internal */
function isDate(value) {
    return isObjectLike(value) && baseGetTag(value) == dateTag;
}
exports.isDate = isDate;
/* istanbul ignore next */
/** @internal */
function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
    }
    const proto = getPrototypeOf(value);
    if (proto === null) {
        return true;
    }
    const Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
}
exports.isPlainObject = isPlainObject;
//# sourceMappingURL=lodash.js.map