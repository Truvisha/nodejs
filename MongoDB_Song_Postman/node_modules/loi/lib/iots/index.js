"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnionType = exports.dictionary = exports.DictionaryType = exports.partial = exports.PartialType = exports.type = exports.InterfaceType = exports.array = exports.ArrayType = exports.recursion = exports.RecursiveType = exports.keyof = exports.KeyofType = exports.literal = exports.LiteralType = exports.Integer = exports.refinement = exports.RefinementType = exports.Function = exports.FunctionType = exports.object = exports.ObjectType = exports.Dictionary = exports.AnyDictionaryType = exports.AnyArrayType = exports.boolean = exports.BooleanType = exports.number = exports.NumberType = exports.string = exports.StringType = exports.never = exports.NeverType = exports.any = exports.AnyType = exports.voidType = exports.VoidType = exports.UndefinedType = exports.nullType = exports.NullType = exports.success = exports.failure = exports.failures = exports.appendContext = exports.getDefaultContext = exports.getValidationError = exports.getContextEntry = exports.getFunctionName = exports.identity = exports.Type = void 0;
exports.void = exports.interface = exports.Array = exports.undefined = exports.null = exports.alias = exports.clean = exports.exact = exports.ExactType = exports.taggedUnion = exports.TaggedUnionType = exports.getTagValue = exports.isTagged = exports.strict = exports.StrictType = exports.readonlyArray = exports.ReadonlyArrayType = exports.readonly = exports.ReadonlyType = exports.tuple = exports.TupleType = exports.intersection = exports.IntersectionType = exports.union = void 0;
const Either_1 = require("./Either");
class Type {
    constructor(
    /** a unique name for this runtime type */
    name, 
    /** a custom type guard */
    is, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    validate, 
    /** converts a value of type A to a value of type O */
    encode) {
        this.name = name;
        this.is = is;
        this.validate = validate;
        this.encode = encode;
    }
    pipe(ab, name) {
        return new Type(name || `pipe(${this.name}, ${ab.name})`, ab.is, (i, c) => {
            const validation = this.validate(i, c);
            if (validation.isLeft()) {
                return validation;
            }
            else {
                return ab.validate(validation.value, c);
            }
        }, this.encode === exports.identity && ab.encode === exports.identity ? exports.identity : b => this.encode(ab.encode(b)));
    }
    asDecoder() {
        return this;
    }
    asEncoder() {
        return this;
    }
    /** a version of `validate` with a default context */
    decode(i) {
        return this.validate(i, exports.getDefaultContext(this));
    }
}
exports.Type = Type;
const identity = (a) => a;
exports.identity = identity;
const getFunctionName = (f) => f.displayName || f.name || `<function${f.length}>`;
exports.getFunctionName = getFunctionName;
const getContextEntry = (key, type) => ({ key, type });
exports.getContextEntry = getContextEntry;
const getValidationError = (value, context) => ({ value, context });
exports.getValidationError = getValidationError;
const getDefaultContext = (type) => [{ key: '', type }];
exports.getDefaultContext = getDefaultContext;
const appendContext = (c, key, type) => {
    const len = c.length;
    const r = Array(len + 1);
    for (let i = 0; i < len; i++) {
        r[i] = c[i];
    }
    r[len] = { key, type };
    return r;
};
exports.appendContext = appendContext;
const failures = (errors) => new Either_1.Left(errors);
exports.failures = failures;
const failure = (value, context) => exports.failures([exports.getValidationError(value, context)]);
exports.failure = failure;
const success = (value) => new Either_1.Right(value);
exports.success = success;
const pushAll = (xs, ys) => {
    const l = ys.length;
    for (let i = 0; i < l; i++) {
        xs.push(ys[i]);
    }
};
//
// basic types
//
class NullType extends Type {
    constructor() {
        super('null', (m) => m === null, (m, c) => (this.is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
        this._tag = 'NullType';
    }
}
exports.NullType = NullType;
/** @alias `null` */
exports.nullType = new NullType();
exports.null = exports.nullType;
class UndefinedType extends Type {
    constructor() {
        super('undefined', (m) => m === void 0, (m, c) => (this.is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
        this._tag = 'UndefinedType';
    }
}
exports.UndefinedType = UndefinedType;
const undefinedType = new UndefinedType();
exports.undefined = undefinedType;
class VoidType extends Type {
    constructor() {
        super('void', undefinedType.is, undefinedType.validate, exports.identity);
        this._tag = 'VoidType';
    }
}
exports.VoidType = VoidType;
/** @alias `void` */
exports.voidType = new VoidType();
exports.void = exports.voidType;
class AnyType extends Type {
    constructor() {
        super('any', (_) => true, exports.success, exports.identity);
        this._tag = 'AnyType';
    }
}
exports.AnyType = AnyType;
exports.any = new AnyType();
class NeverType extends Type {
    constructor() {
        super('never', (_) => false, (m, c) => exports.failure(m, c), 
        /* istanbul ignore next */
        () => {
            throw new Error('cannot encode never');
        });
        this._tag = 'NeverType';
    }
}
exports.NeverType = NeverType;
exports.never = new NeverType();
class StringType extends Type {
    constructor() {
        super('string', (m) => typeof m === 'string', (m, c) => (this.is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
        this._tag = 'StringType';
    }
}
exports.StringType = StringType;
exports.string = new StringType();
class NumberType extends Type {
    constructor() {
        super('number', (m) => typeof m === 'number', (m, c) => (this.is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
        this._tag = 'NumberType';
    }
}
exports.NumberType = NumberType;
exports.number = new NumberType();
class BooleanType extends Type {
    constructor() {
        super('boolean', (m) => typeof m === 'boolean', (m, c) => (this.is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
        this._tag = 'BooleanType';
    }
}
exports.BooleanType = BooleanType;
exports.boolean = new BooleanType();
class AnyArrayType extends Type {
    constructor() {
        super('Array', Array.isArray, (m, c) => (this.is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
        this._tag = 'AnyArrayType';
    }
}
exports.AnyArrayType = AnyArrayType;
const arrayType = new AnyArrayType();
exports.Array = arrayType;
class AnyDictionaryType extends Type {
    constructor() {
        super('Dictionary', (m) => m !== null && typeof m === 'object', (m, c) => (this.is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
        this._tag = 'AnyDictionaryType';
    }
}
exports.AnyDictionaryType = AnyDictionaryType;
exports.Dictionary = new AnyDictionaryType();
class ObjectType extends Type {
    constructor() {
        super('object', exports.Dictionary.is, exports.Dictionary.validate, exports.identity);
        this._tag = 'ObjectType';
    }
}
exports.ObjectType = ObjectType;
exports.object = new ObjectType();
class FunctionType extends Type {
    constructor() {
        super('Function', 
        // tslint:disable-next-line:strict-type-predicates
        (m) => typeof m === 'function', (m, c) => (this.is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
        this._tag = 'FunctionType';
    }
}
exports.FunctionType = FunctionType;
exports.Function = new FunctionType();
//
// refinements
//
class RefinementType extends Type {
    constructor(name, is, validate, encode, type, predicate) {
        super(name, is, validate, encode);
        this.type = type;
        this.predicate = predicate;
        this._tag = 'RefinementType';
    }
}
exports.RefinementType = RefinementType;
const refinement = (type, predicate, name = `(${type.name} | ${exports.getFunctionName(predicate)})`) => new RefinementType(name, (m) => type.is(m) && predicate(m), (i, c) => {
    const validation = type.validate(i, c);
    if (validation.isLeft()) {
        return validation;
    }
    else {
        const a = validation.value;
        return predicate(a) ? exports.success(a) : exports.failure(a, c);
    }
}, type.encode, type, predicate);
exports.refinement = refinement;
exports.Integer = exports.refinement(exports.number, n => n % 1 === 0, 'Integer');
//
// literals
//
class LiteralType extends Type {
    constructor(name, is, validate, encode, value) {
        super(name, is, validate, encode);
        this.value = value;
        this._tag = 'LiteralType';
    }
}
exports.LiteralType = LiteralType;
const literal = (value, name = JSON.stringify(value)) => {
    const is = (m) => m === value;
    return new LiteralType(name, is, (m, c) => (is(m) ? exports.success(value) : exports.failure(m, c)), exports.identity, value);
};
exports.literal = literal;
//
// keyof
//
class KeyofType extends Type {
    constructor(name, is, validate, encode, keys) {
        super(name, is, validate, encode);
        this.keys = keys;
        this._tag = 'KeyofType';
    }
}
exports.KeyofType = KeyofType;
const keyof = (keys, name = `(keyof ${JSON.stringify(Object.keys(keys))})`) => {
    const is = (m) => exports.string.is(m) && keys.hasOwnProperty(m);
    return new KeyofType(name, is, (m, c) => (is(m) ? exports.success(m) : exports.failure(m, c)), exports.identity, keys);
};
exports.keyof = keyof;
//
// recursive types
//
class RecursiveType extends Type {
    constructor(name, is, validate, encode, runDefinition) {
        super(name, is, validate, encode);
        this.runDefinition = runDefinition;
        this._tag = 'RecursiveType';
    }
    get type() {
        return this.runDefinition();
    }
}
exports.RecursiveType = RecursiveType;
const recursion = (name, definition) => {
    let cache;
    const runDefinition = () => {
        if (!cache) {
            cache = definition(Self);
        }
        return cache;
    };
    const Self = new RecursiveType(name, (m) => runDefinition().is(m), (m, c) => runDefinition().validate(m, c), a => runDefinition().encode(a), runDefinition);
    return Self;
};
exports.recursion = recursion;
//
// arrays
//
class ArrayType extends Type {
    constructor(name, is, validate, encode, type) {
        super(name, is, validate, encode);
        this.type = type;
        this._tag = 'ArrayType';
    }
}
exports.ArrayType = ArrayType;
const array = (type, name = `Array<${type.name}>`) => new ArrayType(name, (m) => arrayType.is(m) && m.every(type.is), (m, c) => {
    const arrayValidation = arrayType.validate(m, c);
    if (arrayValidation.isLeft()) {
        return arrayValidation;
    }
    else {
        const xs = arrayValidation.value;
        const len = xs.length;
        let a = xs;
        const errors = [];
        for (let i = 0; i < len; i++) {
            const x = xs[i];
            const validation = type.validate(x, exports.appendContext(c, String(i), type));
            if (validation.isLeft()) {
                pushAll(errors, validation.value);
            }
            else {
                const vx = validation.value;
                if (vx !== x) {
                    if (a === xs) {
                        a = xs.slice();
                    }
                    a[i] = vx;
                }
            }
        }
        return errors.length ? exports.failures(errors) : exports.success(a);
    }
}, type.encode === exports.identity ? exports.identity : a => a.map(type.encode), type);
exports.array = array;
//
// interfaces
//
class InterfaceType extends Type {
    constructor(name, is, validate, encode, props) {
        super(name, is, validate, encode);
        this.props = props;
        this._tag = 'InterfaceType';
    }
}
exports.InterfaceType = InterfaceType;
const getNameFromProps = (props) => `{ ${Object.keys(props)
    .map(k => `${k}: ${props[k].name}`)
    .join(', ')} }`;
const useIdentity = (types, len) => {
    for (let i = 0; i < len; i++) {
        if (types[i].encode !== exports.identity) {
            return false;
        }
    }
    return true;
};
/** @alias `interface` */
const type = (props, name = getNameFromProps(props)) => {
    const keys = Object.keys(props);
    const types = keys.map(key => props[key]);
    const len = keys.length;
    return new InterfaceType(name, (m) => {
        if (!exports.Dictionary.is(m)) {
            return false;
        }
        for (let i = 0; i < len; i++) {
            if (!types[i].is(m[keys[i]])) {
                return false;
            }
        }
        return true;
    }, (m, c) => {
        const dictionaryValidation = exports.Dictionary.validate(m, c);
        if (dictionaryValidation.isLeft()) {
            return dictionaryValidation;
        }
        else {
            const o = dictionaryValidation.value;
            let a = o;
            const errors = [];
            for (let i = 0; i < len; i++) {
                const k = keys[i];
                const ok = o[k];
                const type = types[i];
                const validation = type.validate(ok, exports.appendContext(c, k, type));
                if (validation.isLeft()) {
                    pushAll(errors, validation.value);
                }
                else {
                    const vok = validation.value;
                    if (vok !== ok) {
                        /* istanbul ignore next */
                        if (a === o) {
                            a = Object.assign({}, o);
                        }
                        a[k] = vok;
                    }
                }
            }
            return errors.length ? exports.failures(errors) : exports.success(a);
        }
    }, useIdentity(types, len)
        ? exports.identity
        : a => {
            const s = Object.assign({}, a);
            for (let i = 0; i < len; i++) {
                const k = keys[i];
                const encode = types[i].encode;
                if (encode !== exports.identity) {
                    s[k] = encode(a[k]);
                }
            }
            return s;
        }, props);
};
exports.type = type;
exports.interface = exports.type;
//
// partials
//
class PartialType extends Type {
    constructor(name, is, validate, encode, props) {
        super(name, is, validate, encode);
        this.props = props;
        this._tag = 'PartialType';
    }
}
exports.PartialType = PartialType;
const partial = (props, name = `PartialType<${getNameFromProps(props)}>`) => {
    const keys = Object.keys(props);
    const types = keys.map(key => props[key]);
    const len = keys.length;
    const partials = {};
    for (let i = 0; i < len; i++) {
        partials[keys[i]] = exports.union([types[i], undefinedType]);
    }
    const partial = exports.type(partials);
    return new PartialType(name, partial.is, partial.validate, useIdentity(types, len)
        ? exports.identity
        : a => {
            const s = Object.assign({}, a);
            for (let i = 0; i < len; i++) {
                const k = keys[i];
                const ak = a[k];
                if (ak !== undefined) {
                    s[k] = types[i].encode(ak);
                }
            }
            return s;
        }, props);
};
exports.partial = partial;
//
// dictionaries
//
class DictionaryType extends Type {
    constructor(name, is, validate, encode, domain, codomain) {
        super(name, is, validate, encode);
        this.domain = domain;
        this.codomain = codomain;
        this._tag = 'DictionaryType';
    }
}
exports.DictionaryType = DictionaryType;
const refinedDictionary = exports.refinement(exports.Dictionary, d => Object.prototype.toString.call(d) === '[object Object]');
const dictionary = (domain, codomain, name = `{ [K in ${domain.name}]: ${codomain.name} }`) => {
    const isIndexSignatureRequired = codomain !== exports.any;
    const D = isIndexSignatureRequired ? refinedDictionary : exports.Dictionary;
    return new DictionaryType(name, (m) => D.is(m) && Object.keys(m).every(k => domain.is(k) && codomain.is(m[k])), (m, c) => {
        const dictionaryValidation = D.validate(m, c);
        if (dictionaryValidation.isLeft()) {
            return dictionaryValidation;
        }
        else {
            const o = dictionaryValidation.value;
            const a = {};
            const errors = [];
            const keys = Object.keys(o);
            const len = keys.length;
            let changed = false;
            for (let i = 0; i < len; i++) {
                let k = keys[i];
                const ok = o[k];
                const domainValidation = domain.validate(k, exports.appendContext(c, k, domain));
                const codomainValidation = codomain.validate(ok, exports.appendContext(c, k, codomain));
                if (domainValidation.isLeft()) {
                    pushAll(errors, domainValidation.value);
                }
                else {
                    const vk = domainValidation.value;
                    changed = changed || vk !== k;
                    k = vk;
                }
                if (codomainValidation.isLeft()) {
                    pushAll(errors, codomainValidation.value);
                }
                else {
                    const vok = codomainValidation.value;
                    changed = changed || vok !== ok;
                    a[k] = vok;
                }
            }
            return errors.length ? exports.failures(errors) : exports.success((changed ? a : o));
        }
    }, domain.encode === exports.identity && codomain.encode === exports.identity
        ? exports.identity
        : a => {
            const s = {};
            const keys = Object.keys(a);
            const len = keys.length;
            for (let i = 0; i < len; i++) {
                const k = keys[i];
                s[String(domain.encode(k))] = codomain.encode(a[k]);
            }
            return s;
        }, domain, codomain);
};
exports.dictionary = dictionary;
//
// unions
//
class UnionType extends Type {
    constructor(name, is, validate, encode, types) {
        super(name, is, validate, encode);
        this.types = types;
        this._tag = 'UnionType';
    }
}
exports.UnionType = UnionType;
const union = (types, name = `(${types.map(type => type.name).join(' | ')})`) => {
    const len = types.length;
    return new UnionType(name, (m) => types.some(type => type.is(m)), (m, c) => {
        const errors = [];
        for (let i = 0; i < len; i++) {
            const type = types[i];
            const validation = type.validate(m, exports.appendContext(c, String(i), type));
            if (validation.isRight()) {
                return validation;
            }
            else {
                pushAll(errors, validation.value);
            }
        }
        return exports.failures(errors);
    }, useIdentity(types, len)
        ? exports.identity
        : a => {
            let i = 0;
            for (; i < len - 1; i++) {
                const type = types[i];
                if (type.is(a)) {
                    return type.encode(a);
                }
            }
            return types[i].encode(a);
        }, types);
};
exports.union = union;
//
// intersections
//
class IntersectionType extends Type {
    constructor(name, is, validate, encode, types) {
        super(name, is, validate, encode);
        this.types = types;
        this._tag = 'IntersectionType';
    }
}
exports.IntersectionType = IntersectionType;
function intersection(types, name = `(${types.map(type => type.name).join(' & ')})`) {
    const len = types.length;
    return new IntersectionType(name, (m) => types.every(type => type.is(m)), (m, c) => {
        let a = m;
        const errors = [];
        for (let i = 0; i < len; i++) {
            const type = types[i];
            const validation = type.validate(a, c);
            if (validation.isLeft()) {
                pushAll(errors, validation.value);
            }
            else {
                a = validation.value;
            }
        }
        return errors.length ? exports.failures(errors) : exports.success(a);
    }, useIdentity(types, len)
        ? exports.identity
        : a => {
            let s = a;
            for (let i = 0; i < len; i++) {
                const type = types[i];
                s = type.encode(s);
            }
            return s;
        }, types);
}
exports.intersection = intersection;
//
// tuples
//
class TupleType extends Type {
    constructor(name, is, validate, encode, types) {
        super(name, is, validate, encode);
        this.types = types;
        this._tag = 'TupleType';
    }
}
exports.TupleType = TupleType;
function tuple(types, name = `[${types.map(type => type.name).join(', ')}]`) {
    const len = types.length;
    return new TupleType(name, (m) => arrayType.is(m) && m.length === len && types.every((type, i) => type.is(m[i])), (m, c) => {
        const arrayValidation = arrayType.validate(m, c);
        if (arrayValidation.isLeft()) {
            return arrayValidation;
        }
        else {
            const as = arrayValidation.value;
            let t = as;
            const errors = [];
            for (let i = 0; i < len; i++) {
                const a = as[i];
                const type = types[i];
                const validation = type.validate(a, exports.appendContext(c, String(i), type));
                if (validation.isLeft()) {
                    pushAll(errors, validation.value);
                }
                else {
                    const va = validation.value;
                    if (va !== a) {
                        /* istanbul ignore next */
                        if (t === as) {
                            t = as.slice();
                        }
                        t[i] = va;
                    }
                }
            }
            if (as.length > len) {
                errors.push(exports.getValidationError(as[len], exports.appendContext(c, String(len), exports.never)));
            }
            return errors.length ? exports.failures(errors) : exports.success(t);
        }
    }, useIdentity(types, len) ? exports.identity : a => types.map((type, i) => type.encode(a[i])), types);
}
exports.tuple = tuple;
//
// readonly objects
//
class ReadonlyType extends Type {
    constructor(name, is, validate, encode, type) {
        super(name, is, validate, encode);
        this.type = type;
        this._tag = 'ReadonlyType';
    }
}
exports.ReadonlyType = ReadonlyType;
const readonly = (type, name = `Readonly<${type.name}>`) => new ReadonlyType(name, type.is, (m, c) => type.validate(m, c).map(x => {
    return x;
}), type.encode === exports.identity ? exports.identity : type.encode, type);
exports.readonly = readonly;
//
// readonly arrays
//
class ReadonlyArrayType extends Type {
    constructor(name, is, validate, encode, type) {
        super(name, is, validate, encode);
        this.type = type;
        this._tag = 'ReadonlyArrayType';
    }
}
exports.ReadonlyArrayType = ReadonlyArrayType;
const readonlyArray = (type, name = `ReadonlyArray<${type.name}>`) => {
    const arrayType = exports.array(type);
    return new ReadonlyArrayType(name, arrayType.is, (m, c) => arrayType.validate(m, c).map(x => {
        return x;
    }), arrayType.encode, type);
};
exports.readonlyArray = readonlyArray;
//
// strict types
//
class StrictType extends Type {
    constructor(name, is, validate, encode, props) {
        super(name, is, validate, encode);
        this.props = props;
        this._tag = 'StrictType';
    }
}
exports.StrictType = StrictType;
/**
 * Specifies that only the given properties are allowed
 * @deprecated use `exact` instead
 */
const strict = (props, name = `StrictType<${getNameFromProps(props)}>`) => {
    const exactType = exact(exports.type(props));
    return new StrictType(name, exactType.is, exactType.validate, exactType.encode, props);
};
exports.strict = strict;
const isTagged = (tag) => {
    const f = (type) => {
        if (type instanceof InterfaceType || type instanceof StrictType) {
            return type.props.hasOwnProperty(tag);
        }
        else if (type instanceof IntersectionType) {
            return type.types.some(f);
        }
        else if (type instanceof UnionType) {
            return type.types.every(f);
        }
        else if (type instanceof RefinementType || type instanceof ExactType) {
            return f(type.type);
        }
        else {
            return false;
        }
    };
    return f;
};
exports.isTagged = isTagged;
const findTagged = (tag, types) => {
    const len = types.length;
    const is = exports.isTagged(tag);
    let i = 0;
    for (; i < len - 1; i++) {
        const type = types[i];
        if (is(type)) {
            return type;
        }
    }
    return types[i];
};
const getTagValue = (tag) => {
    const f = (type) => {
        switch (type._tag) {
            case 'InterfaceType':
            case 'StrictType':
                return type.props[tag].value;
            case 'IntersectionType':
                return f(findTagged(tag, type.types));
            case 'UnionType':
                return f(type.types[0]);
            case 'RefinementType':
            case 'ExactType':
            case 'RecursiveType':
                return f(type.type);
        }
    };
    return f;
};
exports.getTagValue = getTagValue;
class TaggedUnionType extends UnionType {
    constructor(name, is, validate, encode, types, tag) {
        super(name, is, validate, encode, types); /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455
        this.tag = tag;
    }
}
exports.TaggedUnionType = TaggedUnionType;
const taggedUnion = (tag, types, name = `(${types.map(type => type.name).join(' | ')})`) => {
    const len = types.length;
    const values = new Array(len);
    const hash = {};
    let useHash = true;
    const get = exports.getTagValue(tag);
    for (let i = 0; i < len; i++) {
        const value = get(types[i]);
        useHash = useHash && exports.string.is(value);
        values[i] = value;
        hash[String(value)] = i;
    }
    const isTagValue = useHash
        ? (m) => exports.string.is(m) && hash.hasOwnProperty(m)
        : (m) => values.indexOf(m) !== -1;
    const getIndex = useHash
        ? tag => hash[tag]
        : tag => {
            let i = 0;
            for (; i < len - 1; i++) {
                if (values[i] === tag) {
                    break;
                }
            }
            return i;
        };
    const TagValue = new Type(values.map(l => JSON.stringify(l)).join(' | '), isTagValue, (m, c) => (isTagValue(m) ? exports.success(m) : exports.failure(m, c)), exports.identity);
    return new TaggedUnionType(name, (v) => {
        if (!exports.Dictionary.is(v)) {
            return false;
        }
        const tagValue = v[tag];
        return TagValue.is(tagValue) && types[getIndex(tagValue)].is(v);
    }, (s, c) => {
        const dictionaryValidation = exports.Dictionary.validate(s, c);
        if (dictionaryValidation.isLeft()) {
            return dictionaryValidation;
        }
        else {
            const d = dictionaryValidation.value;
            const tagValueValidation = TagValue.validate(d[tag], exports.appendContext(c, tag, TagValue));
            if (tagValueValidation.isLeft()) {
                return tagValueValidation;
            }
            else {
                const i = getIndex(tagValueValidation.value);
                const type = types[i];
                return type.validate(d, exports.appendContext(c, String(i), type));
            }
        }
    }, useIdentity(types, len) ? exports.identity : a => types[getIndex(a[tag])].encode(a), types, tag);
};
exports.taggedUnion = taggedUnion;
//
// exact types
//
class ExactType extends Type {
    constructor(name, is, validate, encode, type) {
        super(name, is, validate, encode);
        this.type = type;
        this._tag = 'ExactType';
    }
}
exports.ExactType = ExactType;
const getProps = (type) => {
    switch (type._tag) {
        case 'RefinementType':
        case 'ReadonlyType':
            return getProps(type.type);
        case 'InterfaceType':
        case 'StrictType':
        case 'PartialType':
            return type.props;
        case 'IntersectionType':
            return type.types.reduce((props, type) => Object.assign(props, getProps(type)), {});
    }
};
function exact(type, name = `ExactType<${type.name}>`) {
    const props = getProps(type);
    return new ExactType(name, (m) => type.is(m) && Object.getOwnPropertyNames(m).every(k => props.hasOwnProperty(k)), (m, c) => {
        const looseValidation = type.validate(m, c);
        if (looseValidation.isLeft()) {
            return looseValidation;
        }
        else {
            const o = looseValidation.value;
            const keys = Object.getOwnPropertyNames(o);
            const len = keys.length;
            const errors = [];
            for (let i = 0; i < len; i++) {
                const key = keys[i];
                if (!props.hasOwnProperty(key)) {
                    errors.push(exports.getValidationError(o[key], exports.appendContext(c, key, exports.never)));
                }
            }
            return errors.length ? exports.failures(errors) : exports.success(o);
        }
    }, type.encode, type);
}
exports.exact = exact;
/** Drops the runtime type "kind" */
function clean(type) {
    return type;
}
exports.clean = clean;
function alias(type) {
    return () => type;
}
exports.alias = alias;
//# sourceMappingURL=index.js.map