export declare type Predicate<A> = (a: A) => boolean;
export declare type Refinement<A, B extends A> = (a: A) => a is B;
export declare const toString: (x: any) => string;
/**
 * @since 1.0.0
 */
export declare type Either<L, A> = Left<L, A> | Right<L, A>;
/**
 * Left side of `Either`
 */
export declare class Left<L, A> {
    readonly value: L;
    readonly _tag: 'Left';
    readonly _A: A;
    readonly _L: L;
    constructor(value: L);
    /**
     * The given function is applied if this is a `Right`
     * @obsolete
     */
    map<B>(_f: (a: A) => B): Either<L, B>;
    /** @obsolete */
    ap<B>(fab: Either<L, (a: A) => B>): Either<L, B>;
    /**
     * Flipped version of `ap`
     * @obsolete
     */
    ap_<B, C>(this: Either<L, (b: B) => C>, fb: Either<L, B>): Either<L, C>;
    /**
     * Binds the given function across `Right`
     * @obsolete
     */
    chain<B>(_f: (a: A) => Either<L, B>): Either<L, B>;
    /** @obsolete */
    bimap<V, B>(f: (l: L) => V, _g: (a: A) => B): Either<V, B>;
    /** @obsolete */
    alt(fy: Either<L, A>): Either<L, A>;
    /**
     * Lazy version of `alt`
     *
     * @example
     * import { right } from 'fp-ts/lib/Either'
     *
     * assert.deepStrictEqual(right(1).orElse(() => right(2)), right(1))
     *
     * @since 1.6.0
     * @obsolete
     */
    orElse<M>(fy: (l: L) => Either<M, A>): Either<M, A>;
    /** @obsolete */
    extend<B>(_f: (ea: Either<L, A>) => B): Either<L, B>;
    /** @obsolete */
    reduce<B>(b: B, _f: (b: B, a: A) => B): B;
    /**
     * Applies a function to each case in the data structure
     * @obsolete
     */
    fold<B>(onLeft: (l: L) => B, _onRight: (a: A) => B): B;
    /**
     * Returns the value from this `Right` or the given argument if this is a `Left`
     * @obsolete
     */
    getOrElse(a: A): A;
    /**
     * Returns the value from this `Right` or the result of given argument if this is a `Left`
     * @obsolete
     */
    getOrElseL(f: (l: L) => A): A;
    /**
     * Maps the left side of the disjunction
     * @obsolete
     */
    mapLeft<M>(f: (l: L) => M): Either<M, A>;
    inspect(): string;
    toString(): string;
    /**
     * Returns `true` if the either is an instance of `Left`, `false` otherwise
     * @obsolete
     */
    isLeft(): this is Left<L, A>;
    /**
     * Returns `true` if the either is an instance of `Right`, `false` otherwise
     * @obsolete
     */
    isRight(): this is Right<L, A>;
    /**
     * Swaps the disjunction values
     * @obsolete
     */
    swap(): Either<A, L>;
    /**
     * Returns `Right` with the existing value of `Right` if this is a `Right` and the given predicate `p` holds for the
     * right value, returns `Left(zero)` if this is a `Right` and the given predicate `p` does not hold for the right
     * value, returns `Left` with the existing value of `Left` if this is a `Left`.
     *
     * @example
     * import { right, left } from 'fp-ts/lib/Either'
     *
     * assert.deepStrictEqual(right(12).filterOrElse(n => n > 10, -1), right(12))
     * assert.deepStrictEqual(right(7).filterOrElse(n => n > 10, -1), left(-1))
     * assert.deepStrictEqual(left<number, number>(12).filterOrElse(n => n > 10, -1), left(12))
     *
     * @since 1.3.0
     * @obsolete
     */
    filterOrElse<B extends A>(p: Refinement<A, B>, zero: L): Either<L, B>;
    filterOrElse(p: Predicate<A>, zero: L): Either<L, A>;
    /**
     * Lazy version of `filterOrElse`
     * @since 1.3.0
     * @obsolete
     */
    filterOrElseL<B extends A>(p: Refinement<A, B>, zero: (a: A) => L): Either<L, B>;
    filterOrElseL(p: Predicate<A>, zero: (a: A) => L): Either<L, A>;
    /**
     * Use `filterOrElse` instead
     * @since 1.6.0
     * @deprecated
     */
    refineOrElse<B extends A>(_p: Refinement<A, B>, _zero: L): Either<L, B>;
    /**
     * Lazy version of `refineOrElse`
     * Use `filterOrElseL` instead
     * @since 1.6.0
     * @deprecated
     */
    refineOrElseL<B extends A>(_p: Refinement<A, B>, _zero: (a: A) => L): Either<L, B>;
}
/**
 * Right side of `Either`
 */
export declare class Right<L, A> {
    readonly value: A;
    readonly _tag: 'Right';
    readonly _A: A;
    readonly _L: L;
    constructor(value: A);
    map<B>(f: (a: A) => B): Either<L, B>;
    ap<B>(fab: Either<L, (a: A) => B>): Either<L, B>;
    ap_<B, C>(this: Either<L, (b: B) => C>, fb: Either<L, B>): Either<L, C>;
    chain<B>(f: (a: A) => Either<L, B>): Either<L, B>;
    bimap<V, B>(_f: (l: L) => V, g: (a: A) => B): Either<V, B>;
    alt(_fy: Either<L, A>): Either<L, A>;
    orElse<M>(_fy: (l: L) => Either<M, A>): Either<M, A>;
    extend<B>(f: (ea: Either<L, A>) => B): Either<L, B>;
    reduce<B>(b: B, f: (b: B, a: A) => B): B;
    fold<B>(_onLeft: (l: L) => B, onRight: (a: A) => B): B;
    getOrElse(_a: A): A;
    getOrElseL(_f: (l: L) => A): A;
    mapLeft<M>(_f: (l: L) => M): Either<M, A>;
    inspect(): string;
    toString(): string;
    isLeft(): this is Left<L, A>;
    isRight(): this is Right<L, A>;
    swap(): Either<A, L>;
    filterOrElse<B extends A>(p: Refinement<A, B>, zero: L): Either<L, B>;
    filterOrElse(p: Predicate<A>, zero: L): Either<L, A>;
    filterOrElseL<B extends A>(p: Refinement<A, B>, zero: (a: A) => L): Either<L, B>;
    filterOrElseL(p: Predicate<A>, zero: (a: A) => L): Either<L, A>;
    refineOrElse<B extends A>(p: Refinement<A, B>, zero: L): Either<L, B>;
    refineOrElseL<B extends A>(p: Refinement<A, B>, zero: (a: A) => L): Either<L, B>;
}
export declare const left: <L, A>(l: L) => Either<L, A>;
export declare const right: <L, A>(a: A) => Either<L, A>;
