"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.right = exports.left = exports.Right = exports.Left = exports.toString = void 0;
const getFunctionName = (f) => f.displayName || f.name || `<function${f.length}>`;
const toString = (x) => {
    if (typeof x === 'string') {
        return JSON.stringify(x);
    }
    if (x instanceof Date) {
        return `new Date('${x.toISOString()}')`;
    }
    if (Array.isArray(x)) {
        // tslint:disable-next-line: deprecation
        return `[${x.map(exports.toString).join(', ')}]`;
    }
    if (typeof x === 'function') {
        return getFunctionName(x);
    }
    if (x == null) {
        return String(x);
    }
    if (typeof x.toString === 'function' && x.toString !== Object.prototype.toString) {
        return x.toString();
    }
    try {
        return JSON.stringify(x, null, 2);
    }
    catch (e) {
        return String(x);
    }
};
exports.toString = toString;
/**
 * Left side of `Either`
 */
class Left {
    constructor(value) {
        this.value = value;
        this._tag = 'Left';
    }
    /**
     * The given function is applied if this is a `Right`
     * @obsolete
     */
    map(_f) {
        return this;
    }
    /** @obsolete */
    ap(fab) {
        return (fab.isLeft() ? fab : this);
    }
    /**
     * Flipped version of `ap`
     * @obsolete
     */
    ap_(fb) {
        return fb.ap(this);
    }
    /**
     * Binds the given function across `Right`
     * @obsolete
     */
    chain(_f) {
        return this;
    }
    /** @obsolete */
    bimap(f, _g) {
        return new Left(f(this.value));
    }
    /** @obsolete */
    alt(fy) {
        return fy;
    }
    /**
     * Lazy version of `alt`
     *
     * @example
     * import { right } from 'fp-ts/lib/Either'
     *
     * assert.deepStrictEqual(right(1).orElse(() => right(2)), right(1))
     *
     * @since 1.6.0
     * @obsolete
     */
    orElse(fy) {
        return fy(this.value);
    }
    /** @obsolete */
    extend(_f) {
        return this;
    }
    /** @obsolete */
    reduce(b, _f) {
        return b;
    }
    /**
     * Applies a function to each case in the data structure
     * @obsolete
     */
    fold(onLeft, _onRight) {
        return onLeft(this.value);
    }
    /**
     * Returns the value from this `Right` or the given argument if this is a `Left`
     * @obsolete
     */
    getOrElse(a) {
        return a;
    }
    /**
     * Returns the value from this `Right` or the result of given argument if this is a `Left`
     * @obsolete
     */
    getOrElseL(f) {
        return f(this.value);
    }
    /**
     * Maps the left side of the disjunction
     * @obsolete
     */
    mapLeft(f) {
        return new Left(f(this.value));
    }
    inspect() {
        return this.toString();
    }
    toString() {
        // tslint:disable-next-line: deprecation
        return `left(${exports.toString(this.value)})`;
    }
    /**
     * Returns `true` if the either is an instance of `Left`, `false` otherwise
     * @obsolete
     */
    isLeft() {
        return true;
    }
    /**
     * Returns `true` if the either is an instance of `Right`, `false` otherwise
     * @obsolete
     */
    isRight() {
        return false;
    }
    /**
     * Swaps the disjunction values
     * @obsolete
     */
    swap() {
        return new Right(this.value);
    }
    filterOrElse(_, _zero) {
        return this;
    }
    filterOrElseL(_, _zero) {
        return this;
    }
    /**
     * Use `filterOrElse` instead
     * @since 1.6.0
     * @deprecated
     */
    refineOrElse(_p, _zero) {
        return this;
    }
    /**
     * Lazy version of `refineOrElse`
     * Use `filterOrElseL` instead
     * @since 1.6.0
     * @deprecated
     */
    refineOrElseL(_p, _zero) {
        return this;
    }
}
exports.Left = Left;
/**
 * Right side of `Either`
 */
class Right {
    constructor(value) {
        this.value = value;
        this._tag = 'Right';
    }
    map(f) {
        return new Right(f(this.value));
    }
    ap(fab) {
        return fab.isRight() ? this.map(fab.value) : exports.left(fab.value);
    }
    ap_(fb) {
        return fb.ap(this);
    }
    chain(f) {
        return f(this.value);
    }
    bimap(_f, g) {
        return new Right(g(this.value));
    }
    alt(_fy) {
        return this;
    }
    orElse(_fy) {
        return this;
    }
    extend(f) {
        return new Right(f(this));
    }
    reduce(b, f) {
        return f(b, this.value);
    }
    fold(_onLeft, onRight) {
        return onRight(this.value);
    }
    getOrElse(_a) {
        return this.value;
    }
    getOrElseL(_f) {
        return this.value;
    }
    mapLeft(_f) {
        return new Right(this.value);
    }
    inspect() {
        return this.toString();
    }
    toString() {
        // tslint:disable-next-line: deprecation
        return `right(${exports.toString(this.value)})`;
    }
    isLeft() {
        return false;
    }
    isRight() {
        return true;
    }
    swap() {
        return new Left(this.value);
    }
    filterOrElse(p, zero) {
        return p(this.value) ? this : exports.left(zero);
    }
    filterOrElseL(p, zero) {
        return p(this.value) ? this : exports.left(zero(this.value));
    }
    refineOrElse(p, zero) {
        return p(this.value) ? this : exports.left(zero);
    }
    refineOrElseL(p, zero) {
        return p(this.value) ? this : exports.left(zero(this.value));
    }
}
exports.Right = Right;
const left = (l) => {
    return new Left(l);
};
exports.left = left;
const right = (a) => {
    return new Right(a);
};
exports.right = right;
//# sourceMappingURL=Either.js.map